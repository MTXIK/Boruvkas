package main

import (
	"encoding/binary" // Для чтения бинарных данных из файла.
	"flag"           // Для парсинга аргументов командной строки.
	"fmt"            // Для форматированного ввода/вывода.
	"io"             // Для работы с вводом/выводом.
	"os"             // Для работы с файловой системой.
	"sync"           // Для управления конкурентным доступом с помощью мьютексов и групп ожидания.
)

// Edge представляет ребро в графе.
type Edge struct {
	to     int16  // Конечная вершина ребра.
	weight int16  // Вес ребра.
	next   *Edge  // Указатель на следующее ребро в списке смежности.
}

// Graph представляет граф с использованием списков смежности.
type Graph struct {
	adjacencyList []*Edge // Срез указателей на списки смежности для каждой вершины.
	numVertices   int16   // Общее количество вершин в графе.
}

// MSTEdge представляет ребро в минимальном остовном дереве (МОД).
type MSTEdge struct {
	from   int16 // Начальная вершина ребра.
	to     int16 // Конечная вершина ребра.
	weight int16 // Вес ребра.
}

// DisjointSetUnion представляет структуру данных "Система непересекающихся множеств" (Union-Find).
type DisjointSetUnion struct {
	parent []int16      // Родитель каждого элемента.
	rank   []int16      // Ранг (приблизительная глубина дерева) каждого множества.
	lock   sync.Mutex   // Мьютекс для обеспечения потокобезопасности операций.
}

// NewDisjointSetUnion инициализирует новую систему непересекающихся множеств с `n` элементами.
func NewDisjointSetUnion(n int16) *DisjointSetUnion {
	parent := make([]int16, n) // Создаём срез для хранения родителей каждого элемента.
	rank := make([]int16, n)   // Создаём срез для хранения рангов каждого элемента.

	for i := int16(0); i < n; i++ {
		parent[i] = i // Изначально каждый элемент является своим собственным родителем.
		rank[i] = 0   // Изначальный ранг равен 0.
	}

	return &DisjointSetUnion{parent: parent, rank: rank} // Возвращаем указатель на инициализированную структуру.
}

// Find возвращает представителя (корень) множества, содержащего элемент `x`.
// Используется сжатие путей для оптимизации.
func (dsu *DisjointSetUnion) Find(x int16) int16 {
	if dsu.parent[x] != x {                      // Если текущий элемент не является корнем.
		dsu.parent[x] = dsu.Find(dsu.parent[x]) // Рекурсивно находим корень и сжимаем путь.
	}
	return dsu.parent[x] // Возвращаем корень множества.
}

// Union объединяет множества, содержащие элементы `x` и `y`.
// Использует объединение по рангу для поддержания малой высоты деревьев.
func (dsu *DisjointSetUnion) Union(x, y int16) {
	xroot := dsu.Find(x) // Находим корень множества для элемента `x`.
	yroot := dsu.Find(y) // Находим корень множества для элемента `y`.

	if xroot == yroot {
		return // Оба элемента уже находятся в одном множестве, ничего не делаем.
	}

	dsu.lock.Lock()         // Захватываем мьютекс для обеспечения потокобезопасности.
	defer dsu.lock.Unlock() // Освобождаем мьютекс после выполнения функции.

	// Объединяем два множества на основе ранга.
	if dsu.rank[xroot] < dsu.rank[yroot] {
		dsu.parent[xroot] = yroot // Если ранг корня x меньше ранга корня y, делаем y новым родителем.
	} else if dsu.rank[xroot] > dsu.rank[yroot] {
		dsu.parent[yroot] = xroot // Если ранг корня y меньше ранга корня x, делаем x новым родителем.
	} else {
		dsu.parent[yroot] = xroot // Если ранги равны, делаем x родителем y.
		dsu.rank[xroot]++        // Увеличиваем ранг корня x на 1.
	}
}

// readGraph считывает граф из бинарного файла.
// Формат файла: сначала количество вершин (int16),
// затем тройки (from, to, weight) в формате int16 каждая.
func readGraph(filename string) (*Graph, error) {
	file, err := os.Open(filename) // Открываем файл для чтения.
	if err != nil {
		return nil, err // Возвращаем ошибку, если файл не удалось открыть.
	}
	defer file.Close() // Закрываем файл при выходе из функции.

	var numVertices int16
	// Чтение количества вершин.
	err = binary.Read(file, binary.LittleEndian, &numVertices)
	if err != nil {
		return nil, err // Возвращаем ошибку, если не удалось прочитать количество вершин.
	}

	// Инициализация списка смежности.
	adjacencyList := make([]*Edge, numVertices)

	// Чтение ребер до конца файла.
	for {
		var from, to, weight int16

		// Чтение вершины 'from'.
		err = binary.Read(file, binary.LittleEndian, &from)
		if err == io.EOF {
			break // Достигнут конец файла, выходим из цикла.
		}
		if err != nil {
			return nil, err // Возвращаем ошибку, если не удалось прочитать 'from'.
		}

		// Чтение вершины 'to'.
		err = binary.Read(file, binary.LittleEndian, &to)
		if err != nil {
			return nil, err // Возвращаем ошибку, если не удалось прочитать 'to'.
		}

		// Чтение веса ребра.
		err = binary.Read(file, binary.LittleEndian, &weight)
		if err != nil {
			return nil, err // Возвращаем ошибку, если не удалось прочитать вес.
		}

		// Добавление ребра в список смежности для вершины 'from'.
		adjacencyList[from] = &Edge{
			to:     to,                      // Устанавливаем конечную вершину.
			weight: weight,                  // Устанавливаем вес ребра.
			next:   adjacencyList[from],     // Ссылка на следующее ребро в списке.
		}

		// Поскольку граф неориентированный, добавляем ребро и для вершины 'to'.
		adjacencyList[to] = &Edge{
			to:     from,                     // Устанавливаем обратную конечную вершину.
			weight: weight,                   // Устанавливаем вес ребра.
			next:   adjacencyList[to],        // Ссылка на следующее ребро в списке.
		}
	}

	return &Graph{
		adjacencyList: adjacencyList, // Присваиваем список смежности.
		numVertices:   numVertices,   // Присваиваем количество вершин.
	}, nil // Возвращаем указатель на граф и nil (нет ошибки).
}

// boruvka выполняет алгоритм Борувки для поиска минимального остовного дерева (МОД) графа.
// Возвращает список ребер МОД и общую сумму весов.
func boruvka(graph *Graph) ([]MSTEdge, int) {
	numVertices := graph.numVertices                   // Получаем количество вершин из графа.
	dsu := NewDisjointSetUnion(numVertices)            // Инициализируем систему непересекающихся множеств.
	mstEdges := make([]MSTEdge, 0)                     // Создаём срез для хранения ребер МОД.
	totalWeight := 0                                   // Инициализируем общий вес МОД.
	numComponents := numVertices                       // Изначально каждая вершина — отдельный компонент.

	for numComponents > 1 {                            // Пока осталось больше одного компонента.
		cheapest := make([]*MSTEdge, numVertices)     // Массив для хранения самого дешевого ребра для каждого компонента.

		var wg sync.WaitGroup                         // Создаём группу ожидания для горутин.

		// Параллельный поиск самого дешевого исходящего ребра для каждой вершины.
		for v := int16(0); v < numVertices; v++ {
			wg.Add(1) // Добавляем задачу в группу ожидания.
			go func(v int16) {
				defer wg.Done() // Отмечаем завершение задачи при выходе из функции.

				component := dsu.Find(v) // Находим компонент, к которому принадлежит вершина 'v'.
				edge := graph.adjacencyList[v] // Получаем список смежных ребер для вершины 'v'.

				// Перебор всех ребер вершины 'v'.
				for edge != nil {
					toComponent := dsu.Find(edge.to) // Находим компонент, к которому принадлежит конечная вершина ребра.

					if component != toComponent { // Если ребро ведёт в другой компонент.
						// Проверяем, является ли это ребро самым дешевым для текущего компонента.
						if cheapest[component] == nil || edge.weight < cheapest[component].weight {
							// Обновляем самое дешевое ребро для компонента.
							cheapest[component] = &MSTEdge{
								from:   v,           // Начальная вершина ребра.
								to:     edge.to,     // Конечная вершина ребра.
								weight: edge.weight, // Вес ребра.
							}
						}
					}

					edge = edge.next // Переходим к следующему ребру в списке смежности.
				}
			}(v) // Передаём текущую вершину 'v' в горутину.
		}

		wg.Wait() // Ждём завершения всех горутин.

		// Добавление самых дешевых ребер в МОД.
		for i := int16(0); i < numVertices; i++ {
			if cheapest[i] != nil { // Если для компонента найдено самое дешевое ребро.
				u := cheapest[i].from       // Начальная вершина ребра.
				v := cheapest[i].to         // Конечная вершина ребра.
				setU := dsu.Find(u)          // Найти компонент для вершины 'u'.
				setV := dsu.Find(v)          // Найти компонент для вершины 'v'.

				if setU != setV { // Если вершины находятся в разных компонентах.
					dsu.Union(setU, setV)                     // Объединяем компоненты.
					totalWeight += int(cheapest[i].weight)    // Добавляем вес ребра к общему весу.
					mstEdges = append(mstEdges, *cheapest[i]) // Добавляем ребро в МОД.
					numComponents--                           // Уменьшаем количество компонентов.
				}
			}
		}
	}

	return mstEdges, totalWeight // Возвращаем список ребер МОД и общий вес.
}

// writeOutput записывает информацию о МОД в указанный выходной файл.
// Включает общий вес и список ребер МОД.
func writeOutput(filename string, totalWeight int, mstEdges []MSTEdge) error {
	file, err := os.Create(filename) // Создаём (или перезаписываем) выходной файл.
	if err != nil {
		return err // Возвращаем ошибку, если файл не удалось создать.
	}
	defer file.Close() // Закрываем файл при выходе из функции.

	// Запись общего веса МОД.
	_, err = fmt.Fprintf(file, "Вес минимального остовного дерева: %d\n", totalWeight)
	if err != nil {
		return err // Возвращаем ошибку, если не удалось записать данные.
	}

	// Запись заголовка для списка ребер МОД.
	_, err = fmt.Fprintln(file, "Ребра дерева:")
	if err != nil {
		return err // Возвращаем ошибку, если не удалось записать данные.
	}

	// Запись каждого ребра в МОД.
	for _, edge := range mstEdges {
		// Предполагается, что вершины нумеруются с 0.
		_, err = fmt.Fprintf(file, "(%d, %d, %d)\n", edge.from, edge.to, edge.weight)
		if err != nil {
			return err // Возвращаем ошибку, если не удалось записать данные.
		}
	}

	return nil // Возвращаем nil, если всё прошло успешно.
}

// main является точкой входа в программу.
// Он парсит аргументы командной строки, считывает граф, вычисляет МОД с помощью алгоритма Борувки,
// и записывает результаты в указанный выходной файл.
func main() {
	// Парсинг аргументов командной строки.
	outputFile := flag.String("o", "output.txt", "Имя выходного файла") // Определяем флаг -o для имени выходного файла.
	flag.Parse() // Парсим флаги из командной строки.

	// Проверка наличия входного файла.
	if flag.NArg() < 1 { // Если количество не-флаговых аргументов меньше 1.
		fmt.Println("Использование: program inputfile [-o outputfile]") // Выводим инструкцию по использованию.
		return // Завершаем программу.
	}

	inputFile := flag.Arg(0) // Получение имени входного файла из аргументов.

	// Считывание графа из бинарного файла.
	graph, err := readGraph(inputFile) // Вызываем функцию для чтения графа.
	if err != nil {
		fmt.Println("Ошибка при чтении графа:", err) // Выводим ошибку, если не удалось прочитать граф.
		return // Завершаем программу.
	}

	// Запуск алгоритма Борувки для поиска МОД.
	mstEdges, totalWeight := boruvka(graph) // Вызываем функцию алгоритма Борувки.

	// Запись результатов МОД в выходной файл.
	err = writeOutput(*outputFile, totalWeight, mstEdges) // Вызываем функцию для записи результатов.
	if err != nil {
		fmt.Println("Ошибка при записи вывода:", err) // Выводим ошибку, если не удалось записать результаты.
	}
}
