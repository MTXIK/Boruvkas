# Алгоритм Борувки для поиска минимального остовного дерева

## Описание

Данная программа реализует **алгоритм Борувки** для нахождения **минимального остовного дерева (МОД)** в неориентированном графе. Граф задается в виде списков смежности, считываемых из бинарного файла. Программа принимает имя входного файла в качестве обязательного параметра и, опционально, имя выходного файла с помощью ключа `-o`. Если имя выходного файла не указано, результаты записываются в файл `output.txt` по умолчанию.

### Основные возможности программы:

1. **Вычисление минимального остовного дерева** графа с использованием алгоритма Борувки.
2. **Вывод суммарного веса МОД**.
3. **Отображение списка ребер**, входящих в МОД.

## Требования

- **Компилятор Go**: Версия 1.13 или выше.
- **Операционная система**: Windows, Linux, macOS или любая другая ОС с поддержкой Go.

## Сборка

1. **Скачайте исходный код** программы и сохраните его в файл, например, `boruvka.go`.

2. **Установите Go**, если он ещё не установлен. Следуйте официальной [инструкции по установке Go](https://golang.org/doc/install).

3. **Откройте терминал** или командную строку и перейдите в директорию с исходным кодом.

4. **Скомпилируйте программу** с помощью команды `go build`:

   ```bash
   go build -o boruvka boruvka.go
   ```

   Где `boruvka.go` — имя файла с исходным кодом, а `boruvka` — имя создаваемого исполняемого файла.

## Использование

Запустите программу, передав в качестве обязательного аргумента имя входного бинарного файла. Опционально можно указать имя выходного файла с помощью ключа `-o`.

### Синтаксис

```bash
./boruvka <input_file.bm> [-o <output_file.txt>]
```

- `<input_file.bm>`: Имя входного бинарного файла, содержащего список ребер графа.
- `-o <output_file.txt>`: (Опционально) Имя выходного текстового файла. Если ключ `-o` не указан, результаты записываются в файл `output.txt` по умолчанию.

### Пример использования

**Без указания выходного файла (результаты будут записаны в `output.txt`):**

```bash
./boruvka graph.bm
```

**С указанием выходного файла:**

```bash
./boruvka graph.bm -o results.txt
```

## Формат входного файла

Входной файл должен быть бинарным и содержать список ребер графа с 16-битными целыми числами (`int16`). Структура файла следующая:

1. **Первое число (`int16`)**: Количество вершин `n` в графе.
2. **Далее следует перечисление ребер**: Каждое ребро задается тремя `int16` числами:
   - **Начальная вершина ребра** (`from`)
   - **Конечная вершина ребра** (`to`)
   - **Вес ребра** (`weight`)

Если вес равен `0`, предполагается отсутствие ребра между соответствующими вершинами.

### Пример создания бинарного файла

Вот пример того, как можно создать бинарный файл с ребрами графа на языке Go:

```go
package main

import (
	"encoding/binary"
	"fmt"
	"os"
)

func main() {
	numVertices := int16(4) // Число вершин

	// Список ребер: from, to, weight
	edges := []int16{
		0, 1, 10,
		0, 2, 6,
		0, 3, 5,
		1, 3, 15,
		2, 3, 4,
	}

	file, err := os.Create("graph.bm") // Создаём бинарный файл
	if err != nil {
		fmt.Println("Не удалось создать файл:", err)
		return
	}
	defer file.Close()

	// Записываем количество вершин
	err = binary.Write(file, binary.LittleEndian, numVertices)
	if err != nil {
		fmt.Println("Не удалось записать количество вершин:", err)
		return
	}

	// Записываем список ребер
	for i := 0; i < len(edges); i += 3 {
		from := edges[i]
		to := edges[i+1]
		weight := edges[i+2]
		err = binary.Write(file, binary.LittleEndian, from)
		if err != nil {
			fmt.Println("Не удалось записать ребро:", err)
			return
		}
		err = binary.Write(file, binary.LittleEndian, to)
		if err != nil {
			fmt.Println("Не удалось записать ребро:", err)
			return
		}
		err = binary.Write(file, binary.LittleEndian, weight)
		if err != nil {
			fmt.Println("Не удалось записать ребро:", err)
			return
		}
	}

	fmt.Println("Бинарный файл graph.bm успешно создан.")
}
```

Этот код создаст бинарный файл `graph.bm`, содержащий граф с 4 вершинами и заданными ребрами.

## Формат выходного файла

Выходной файл представляет собой текстовый файл, содержащий следующую информацию:

1. **Суммарный вес минимального остовного дерева:**

   ```
   Вес минимального остовного дерева: <totalWeight>
   ```

2. **Список ребер, входящих в минимальное остовное дерево:**

   ```
   Ребра дерева:
   (from, to, weight)
   (from, to, weight)
   ...
   ```

### Пример выходного файла

```
Вес минимального остовного дерева: 19
Ребра дерева:
(0, 1, 10)
(0, 3, 5)
(2, 3, 4)
```

## Функциональность

- **Чтение из файла:** Программа открывает бинарный файл, считывает количество вершин и список ребер графа, строя списки смежности.

- **Выполнение алгоритма Борувки:** Программа находит минимальное остовное дерево графа с использованием алгоритма Борувки, который включает:
  - **Поиск самого дешевого ребра** для каждого компонента.
  - **Объединение компонентов** при помощи структуры данных "Система непересекающихся множеств" (Union-Find).
  - **Параллельная обработка** вершин с использованием горутин для повышения производительности.

- **Запись результатов:** Суммарный вес МОД и список ребер, входящих в МОД, записываются в указанный выходной файл.

- **Освобождение памяти:** После завершения работы, программа освобождает динамически выделенную память для ребер.

## Структура данных

- **Edge:** Представляет ребро в графе с конечной вершиной, весом и указателем на следующее ребро в списке смежности.

- **Graph:** Представляет граф с использованием списков смежности и содержит общее количество вершин.

- **MSTEdge:** Представляет ребро в минимальном остовном дереве, включая начальную и конечную вершины и вес ребра.

- **DisjointSetUnion:** Реализует структуру данных "Система непересекающихся множеств" (Union-Find) с оптимизациями по рангу и сжатию путей для эффективного объединения и поиска компонентов.

## Алгоритм Борувки

Алгоритм Борувки выполняется следующим образом:

1. **Инициализация:** Каждая вершина считается отдельным компонентом.

2. **Поиск самых дешевых ребер:** Для каждого компонента находится самое дешевое ребро, соединяющее его с другим компонентом.

3. **Объединение компонентов:** Добавляются самые дешевые ребра к МОД, объединяя соответствующие компоненты.

4. **Повторение:** Процесс повторяется до тех пор, пока все вершины не объединятся в одно связное множество, образуя МОД.

## Тесты

Тестовые файлы находятся в папке `tests`. В этой папке вы найдете примеры бинарных файлов с графами различных типов, включая графы с разными весами ребер и различными конфигурациями.

### Пример использования тестов

1. **Перейдите в папку с тестами:**

   ```bash
   cd tests
   ```

2. **Запустите программу с одним из тестовых файлов:**

   ```bash
   ../boruvka test1.bm -o result1.txt
   ```

3. **Просмотрите результаты в выходном файле:**

   ```bash
   cat result1.txt
   ```